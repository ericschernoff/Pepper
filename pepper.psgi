#!/usr/bin/env perl
# This is the PSGI script which runs Pepper as a Plack application
# Please see $Pepper/configs/start_pepper.bash on how to start up the app,
# including environmental variables.
# Each worker/thread started by Plack/Gazelle (or other) will run a copy of this script

# Please see the Perldoc notes below for more info about what this is.

# load our plack modules
use Plack::Request;		# access the incoming request info (like $q = new CGI;)
use Plack::Response;	# handles the outgoing respose
use Plack::Builder;		# enable use of middleware
use Plack::Middleware::DBIx::DisconnectAll;		# protect DB connections
use Plack::Middleware::Timeout;
use File::RotateLogs;	# log rotation
# probably more middleware to come

# load up the modules we require
use Pepper;
use Pepper::Utilities;

# Here is the PSGI app itself; Plack needs a code reference, so work it like so:
my $app = sub {
	# grab the incoming request
	my $request = 'Plack::Request'->new(shift);
	# set up the response object
	my $response = 'Plack::Response'->new(200);
	
	# eval{} the real work, so we can maybe log the errors
	eval {
		$pepper = Pepper->new(
			'request' => $request, 
			'response' => $response,
		);
		
		# put our logic for find and executing the needed handler into the $pepper object
		$pepper->execute_handler();
		# that will retrieve and ship out the content
		
	};
	
	# catch the 'super' fatals, which is when the code breaks (usually syntax-error) before logging
	if ($@ && $@ !~ /^(Execution stopped|Redirected)/) {
		my $error_message = $@;

		# tie our UtilityBelt to the current request
		my $utils = Pepper::Utilities->new(); # need this for logging
		$utils->{response} = $response;
		$utils->{request} = $request;
			
		# send the message to to client
		if ($@ =~ /Plack::Middleware::Timeout/) { 
			# we want to log exactly what happened
			$utils->logger({
				'url' => 'https://'.$request->env->{HTTP_HOST}.$request->request_uri(),
				'params' => $request->parameters,
			},'timeouts');
			# omnitool_routines.js will know how to handle this
			$utils->send_response('Execution failed due to timeout.',3); 

		# display via the utility belt
		} else {
			$utils->send_response('Fatal Error: '.$error_message,3);
		}
	}
	
	# vague server name
	$response->header('Server' => 'Pepper');

	# finish up with our response
	$response->finalize;
};

# rotate the logs every day
my $rotatelogs = File::RotateLogs->new(
	logfile => '/opt/pepper/logs/pepper_access_log.%Y%m%d%H%M',
	linkname => '/opt/pepper/logs/pepper_access_log',
	rotationtime => 86400,
	maxage => 86400,
);

# use Plack::Middleware::ReverseProxy to make sure the remote_addr is actually the client's IP address
builder {
	# try not to have hung MySQL connections
	enable "DBIx::DisconnectAll";
	# set a reasonable timeout of 30 seconds
	# response will be generated by error handling in main subroutine
	# enable "Timeout", timeout  => 30;
	# use Plack::Middleware::ReverseProxy to make sure the remote_addr is actually the client's IP address
	enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' }
	"Plack::Middleware::ReverseProxy";
	# nice access log
	enable 'Plack::Middleware::AccessLog',
		format => '%P - %h - %t - %V - %r - %b - "%{User-agent}i"',
		# the worker PID, the Remote Client IP, Local Time of Service, HTTP Type, URI, HTTP Ver,
		# Response Length and client browser; separated by dashes
		logger => sub { 
			$rotatelogs->print(@_) 
		};
	$app;
};

# plack seems not to like 'exit' commands in these scripts

